#!/usr/bin/env bash
# Summary: Register a python exacutable in outside of pyenv
#
# Usage: pyenv register [-f|--force] <python-executable> [<name>]
#
# <name>     A name of environment will be created in versions.
#            If ommited, name is automatically defined.
#
# -f/--force Install even if the version appears to be installed already
#
usage() {
  # We can remove the sed fallback once pyenv 0.4.0 is widely available.
  pyenv-help register 2>/dev/null < "$0"
  [ -z "$1" ] || exit "$1"
}

if [ $# -lt 1 ]; then
  usage 1
fi

FORCE=0
ARGS=()

while [ -n "$1" ]; do
  case "$1" in
    "-f" | "--force" )
      FORCE=1
      ;;
    * )
      ARGS=("${ARGS[@]}" "$1")
      ;;
  esac
  shift
done

if [ ${#ARGS[@]} -gt 2 ]; then
  usage 1
fi

PYTHON=${ARGS[0]}

if [ ${#ARGS[@]} -eq 2 ]; then
  NAME=${ARGS[1]}
else
  NAME=$(
    "$PYTHON" -c '
from platform import *
import sys
imp = python_implementation().lower()
v = ".".join(map(str, sys.version_info[:3]))
if imp == "cpython":
  print("system-" + v)
else:
  print("system-" + imp + "-" + v)
'
  )
fi

VIRTUALENV_OPTIONS=("--system-site-packages")
DEST_DIR="$PYENV_ROOT/versions/$NAME"
echo "Register $PYTHON => $DEST_DIR"

if [ $FORCE -eq "0" ] && [ -e "$DEST_DIR" ]; then
  echo "$DEST_DIR already exists. Use --force option to override." >&2
  exit 1
fi

if ! "$PYTHON" -c 'import virtualenv' &> /dev/null; then
  "$PYTHON" -m pip install --user virtualenv || {
    exit 1
  }
fi

"$PYTHON" -m virtualenv -p "$PYTHON" ${VIRTUALENV_OPTIONS[*]} "$DEST_DIR" || {
  exit 1
}
